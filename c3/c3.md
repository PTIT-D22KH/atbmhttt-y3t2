Tuyệt vời! Dưới đây là 100 câu hỏi trắc nghiệm cho Chương 3: Đảm Bảo An Toàn Thông Tin Dựa Trên Mã Hóa, được phân bổ theo độ khó dễ > trung bình > khó.

---

**Mức độ: Dễ**

Q1. Mật mã (Cryptography) theo định nghĩa trong tài liệu là gì?
A. Là hành động hoặc nghệ thuật viết các ký tự bí mật, hoặc mã hóa dữ liệu để chỉ người cụ thể giải mã được.
B. Là việc gửi thông tin qua mạng Internet.
C. Là việc lưu trữ dữ liệu trên đám mây.
D. Là việc sử dụng phần mềm diệt virus.
**Correct answer: A**
**Explanation:** Trang 67 định nghĩa mật mã dựa trên từ điển Webster và Free Online Dictionary of Computing, nhấn mạnh việc viết ký tự bí mật hoặc mã hóa dữ liệu.

Q2. Bản rõ (Plaintext) là gì?
A. Thông tin ở dạng chưa mã hóa, có thể hiểu được.
B. Thông tin đã được mã hóa.
C. Khóa dùng để mã hóa.
D. Giải thuật mã hóa.
**Correct answer: A**
**Explanation:** Trang 67 định nghĩa Bản rõ (Plaintext) là thông tin ở dạng có thể hiểu được, chưa mã hóa.

Q3. Bản mã (Ciphertext) là gì?
A. Thông tin ở dạng đã bị xáo trộn sau khi mã hóa.
B. Thông tin gốc trước khi mã hóa.
C. Khóa dùng để giải mã.
D. Người gửi thông tin.
**Correct answer: A**
**Explanation:** Trang 67 định nghĩa Bản mã (Ciphertext) là thông tin ở dạng đã bị xáo trộn, đã được mã hóa.

Q4. Mã hóa (Encryption) là hành động gì?
A. Xáo trộn bản rõ để chuyển thành bản mã.
B. Giải xáo trộn bản mã để chuyển thành bản rõ.
C. Tạo ra khóa bí mật.
D. Kiểm tra tính toàn vẹn của thông tin.
**Correct answer: A**
**Explanation:** Trang 67 định nghĩa Mã hóa (Encryption) là hành động xáo trộn (scrambling) bản rõ để chuyển thành bản mã.

Q5. Giải mã (Decryption) là hành động gì?
A. Giải xáo trộn bản mã để chuyển thành bản rõ.
B. Xáo trộn bản rõ để chuyển thành bản mã.
C. Sinh khóa công khai.
D. Phân phối khóa bí mật.
**Correct answer: A**
**Explanation:** Trang 67 định nghĩa Giải mã (Decryption) là hành động giải xáo trộn (unscrambling) bản mã để chuyển thành bản rõ.

Q6. Một bộ mã hóa (Cipher) bao gồm những gì?
A. Một giải thuật để mã hóa và một giải thuật để giải mã.
B. Chỉ một giải thuật mã hóa.
C. Chỉ một khóa bí mật.
D. Bản rõ và bản mã.
**Correct answer: A**
**Explanation:** Trang 67 định nghĩa Một bộ mã hóa (Cipher) gồm một giải thuật để mã hóa và một giải thuật để giải mã thông tin.

Q7. Khóa (Key) trong mật mã dùng để làm gì?
A. Sử dụng trong giải thuật mã hóa và giải mã.
B. Lưu trữ bản rõ.
C. Lưu trữ bản mã.
D. Xác định người gửi.
**Correct answer: A**
**Explanation:** Trang 67 định nghĩa Khóa/Chìa (Key) là một chuỗi được sử dụng trong giải thuật mã hóa và giải mã.

Q8. Mã hóa khóa đối xứng (Symmetric key cryptography) sử dụng bao nhiêu khóa?
A. Một khóa duy nhất cho cả mã hóa và giải mã.
B. Hai khóa: một công khai, một bí mật.
C. Nhiều khóa khác nhau cho mỗi lần mã hóa.
D. Không sử dụng khóa.
**Correct answer: A**
**Explanation:** Trang 68 định nghĩa Mã hóa khóa đối xứng là dạng mã hóa trong đó một khóa được sử dụng cho cả khâu mã hóa và khâu giải mã.

Q9. Mã hóa khóa đối xứng còn được gọi là gì?
A. Mã hóa khóa bí mật (Secret key cryptography).
B. Mã hóa khóa công khai (Public key cryptography).
C. Hàm băm (Hash function).
D. Chữ ký số (Digital signature).
**Correct answer: A**
**Explanation:** Trang 68 giải thích do khóa sử dụng chung cần giữ bí mật nên mã hóa khóa đối xứng còn được gọi là mã hóa khóa bí mật.

Q10. Mã hóa khóa bất đối xứng (Asymmetric key cryptography) sử dụng mấy khóa?
A. Một cặp khóa: khóa công khai và khóa riêng.
B. Một khóa duy nhất.
C. Ba khóa khác nhau.
D. Không sử dụng khóa nào cả.
**Correct answer: A**
**Explanation:** Trang 68 định nghĩa Mã hóa khóa bất đối xứng sử dụng một cặp khóa: khóa công khai (public key) dùng để mã hóa, khóa riêng (private key) dùng để giải mã.

Q11. Trong mã hóa khóa bất đối xứng, khóa nào cần được giữ bí mật?
A. Khóa riêng (private key).
B. Khóa công khai (public key).
C. Cả hai khóa.
D. Không khóa nào cần giữ bí mật.
**Correct answer: A**
**Explanation:** Trang 68 nêu rõ chỉ có khóa riêng cần phải giữ bí mật, còn khóa công khai có thể phổ biến rộng rãi.

Q12. Hàm băm (Hash function) là gì?
A. Một ánh xạ chuyển dữ liệu kích thước thay đổi về dữ liệu kích thước cố định.
B. Một phương pháp mã hóa khóa đối xứng.
C. Một phương pháp mã hóa khóa bất đối xứng.
D. Một phương pháp trao đổi khóa.
**Correct answer: A**
**Explanation:** Trang 68 định nghĩa Hàm băm (Hash function) là một ánh xạ chuyển các dữ liệu có kích thước thay đổi về dữ liệu có kích thước cố định.

Q13. Kết quả đầu ra của hàm băm thường được gọi là gì?
A. Digest (bản tóm lược/chuỗi đại diện).
B. Ciphertext (bản mã).
C. Plaintext (bản rõ).
D. Key (khóa).
**Correct answer: A**
**Explanation:** Trang 68 và Hình 3.4 (Trang 69) cho thấy đầu ra của hàm băm được gọi là Digest.

Q14. Thám mã (Cryptanalysis) là quá trình gì?
A. Giải mã thông điệp mà không cần biết trước giải thuật hoặc khóa mã.
B. Mã hóa thông điệp bằng khóa công khai.
C. Tạo ra chữ ký số cho thông điệp.
D. Phân phối khóa bí mật an toàn.
**Correct answer: A**
**Explanation:** Trang 69 định nghĩa Thám mã hay phá mã (Cryptanalysis) là quá trình giải mã thông điệp đã bị mã hóa mà không cần có trước thông tin về giải thuật mã hóa và khóa mã.

Q15. Mã hóa dòng (Stream cipher) mã hóa dữ liệu như thế nào?
A. Mã hóa từng bit hoặc từng ký tự của bản rõ.
B. Mã hóa từng khối dữ liệu có kích thước cố định.
C. Sử dụng hai khóa khác nhau.
D. Chỉ sử dụng hàm băm.
**Correct answer: A**
**Explanation:** Trang 71 định nghĩa Mã hóa dòng là kiểu mã hóa mà từng bit, hoặc ký tự của bản rõ được kết hợp với từng bit, hoặc ký tự tương ứng của khóa.

Q16. Mã hóa khối (Block cipher) mã hóa dữ liệu như thế nào?
A. Chia dữ liệu thành các khối kích thước cố định rồi mã hóa từng khối.
B. Mã hóa từng bit dữ liệu một.
C. Sử dụng khóa thay đổi liên tục.
D. Kết hợp bản rõ với one-time pad.
**Correct answer: A**
**Explanation:** Trang 71 định nghĩa Mã hóa khối là kiểu mã hóa mà dữ liệu được chia ra thành từng khối có kích thước cố định để mã hóa và giải mã.

Q17. Mục đích chính của việc sử dụng mã hóa trong các dịch vụ xác thực (Kerberos, SSO) là gì?
A. Bảo vệ thông tin xác thực (mật khẩu, vé) khi truyền qua mạng.
B. Tăng tốc độ đăng nhập.
C. Giảm số lượng mật khẩu người dùng cần nhớ.
D. Lưu trữ lịch sử đăng nhập.
**Correct answer: A**
**Explanation:** Trang 72 liệt kê ứng dụng của mã hóa, bao gồm các dịch vụ xác thực. Mã hóa giúp bảo vệ các thông tin nhạy cảm trong quá trình xác thực.

Q18. Phương pháp mã hóa thay thế (Substitution) hoạt động như thế nào?
A. Thay thế một giá trị (ký tự, bit) này bằng một giá trị khác.
B. Đổi chỗ vị trí các giá trị (ký tự, bit).
C. Thực hiện phép XOR giữa bản rõ và khóa.
D. Sử dụng hàm băm một chiều.
**Correct answer: A**
**Explanation:** Trang 72 định nghĩa Phương pháp thay thế là phương pháp thay thế một giá trị này bằng một giá trị khác (ví dụ: thay ký tự bằng ký tự khác).

Q19. Mã hóa Caesar cipher là một ví dụ của phương pháp mã hóa nào?
A. Thay thế (Substitution).
B. Hoán vị (Permutation).
C. XOR.
D. Hàm băm.
**Correct answer: A**
**Explanation:** Trang 72 giới thiệu Caesar cipher là hệ mã hóa thay thế nổi tiếng, dịch chuyển ký tự đi một số vị trí cố định.

Q20. Phương pháp mã hóa hoán vị (Permutation/Transposition) hoạt động như thế nào?
A. Sắp xếp lại (đổi chỗ) vị trí các giá trị (bit, ký tự) trong một khối.
B. Thay thế ký tự này bằng ký tự khác.
C. Cộng bản rõ với khóa.
D. Nén dữ liệu trước khi gửi.
**Correct answer: A**
**Explanation:** Trang 73 định nghĩa Phương pháp hoán vị thực hiện sắp xếp lại các giá trị trong một khối bản rõ để tạo bản mã.

Q21. Phương pháp mã hóa XOR thực hiện phép toán nào?
A. Phép toán logic XOR giữa bit bản rõ và bit khóa.
B. Phép cộng số học.
C. Phép thay thế ký tự.
D. Phép hoán vị bit.
**Correct answer: A**
**Explanation:** Trang 73 mô tả Phương pháp mã hóa XOR sử dụng phép toán logic XOR để tạo bản mã.

Q22. Phương pháp mã hóa Vernam sử dụng cái gì đặc biệt?
A. One-time pad (tập ký tự/khóa dùng một lần).
B. Khóa công khai.
C. Hàm băm SHA1.
D. Thuật toán DES.
**Correct answer: A**
**Explanation:** Trang 74 mô tả Phương pháp Vernam sử dụng một tập ký tự gọi là one-time pad, mỗi ký tự chỉ dùng 1 lần.

Q23. Độ dài của chuỗi băm đầu ra của hàm MD5 là bao nhiêu?
A. 128 bit.
B. 160 bit.
C. 256 bit.
D. 512 bit.
**Correct answer: A**
**Explanation:** Trang 75 liệt kê Các hàm băm MD2, MD4, MD5 với độ dài chuỗi đầu ra là 128 bit.

Q24. Độ dài của chuỗi băm đầu ra của hàm SHA1 là bao nhiêu?
A. 160 bit.
B. 128 bit.
C. 256 bit.
D. 512 bit.
**Correct answer: A**
**Explanation:** Trang 75 liệt kê Các hàm băm SHA0, SHA1 với độ dài chuỗi đầu ra là 160 bit.

Q25. DES (Data Encryption Standard) là giải thuật mã hóa thuộc loại nào?
A. Mã hóa khối khóa đối xứng.
B. Mã hóa dòng khóa đối xứng.
C. Mã hóa khóa bất đối xứng.
D. Hàm băm không khóa.
**Correct answer: A**
**Explanation:** Trang 76 giới thiệu DES là dạng mã hóa khối, sử dụng khóa đối xứng (mặc dù khóa cần giữ bí mật).

Q26. Kích thước khối dữ liệu vào của DES là bao nhiêu?
A. 64 bit.
B. 128 bit.
C. 56 bit.
D. 160 bit.
**Correct answer: A**
**Explanation:** Trang 76 nêu DES là dạng mã hóa khối với khối dữ liệu vào kích thước 64 bit.

Q27. Kích thước khóa hiệu dụng của DES là bao nhiêu?
A. 56 bit.
B. 64 bit.
C. 128 bit.
D. 16 bit.
**Correct answer: A**
**Explanation:** Trang 76 nêu DES sử dụng khóa 64 bit, trong đó thực sử dụng 56 bit (kích thước hiệu dụng), 8 bit còn lại dùng kiểm tra chẵn lẻ.

Q28. AES (Advanced Encryption Standard) là giải thuật mã hóa thuộc loại nào?
A. Mã hóa khối khóa đối xứng.
B. Mã hóa dòng khóa đối xứng.
C. Mã hóa khóa bất đối xứng.
D. Hàm băm có khóa.
**Correct answer: A**
**Explanation:** Trang 79 giới thiệu AES là chuẩn mã hóa dữ liệu, dạng mã hóa khối, sử dụng khóa bí mật (đối xứng).

Q29. Kích thước khối dữ liệu vào của AES là bao nhiêu?
A. 128 bit.
B. 64 bit.
C. 192 bit.
D. 256 bit.
**Correct answer: A**
**Explanation:** Trang 79 nêu AES là dạng mã hóa khối, với khối dữ liệu vào có kích thước là 128 bit.

Q30. AES hỗ trợ các kích thước khóa nào?
A. 128, 192, hoặc 256 bit.
B. Chỉ 56 bit.
C. Chỉ 64 bit.
D. 512 hoặc 1024 bit.
**Correct answer: A**
**Explanation:** Trang 79 nêu AES hỗ trợ khóa bí mật với kích thước có thể là 128, 192, hoặc 256 bit.

Q31. RSA là giải thuật mã hóa thuộc loại nào?
A. Mã hóa khóa bất đối xứng.
B. Mã hóa khóa đối xứng.
C. Mã hóa dòng.
D. Hàm băm.
**Correct answer: A**
**Explanation:** Trang 83-84 giới thiệu RSA là một giải thuật mã hóa khóa bất đối xứng (khóa công khai).

Q32. Độ an toàn của RSA dựa trên bài toán nào?
A. Tính khó của việc phân tích số nguyên rất lớn thành thừa số.
B. Tính khó của bài toán Logarit rời rạc.
C. Tính khó của việc tìm chu trình Hamilton.
D. Tính khó của việc giải mã DES.
**Correct answer: A**
**Explanation:** Trang 84 nêu Độ an toàn của RSA dựa trên tính khó của việc phân tích số nguyên rất lớn (cỡ hàng trăm chữ số thập phân) ra thừa số.

Q33. Chữ ký số (Digital Signature) dùng để đảm bảo điều gì?
A. Tính toàn vẹn và xác thực nguồn gốc của thông điệp.
B. Tính bí mật của thông điệp.
C. Tính sẵn dùng của hệ thống.
D. Tốc độ truyền thông điệp.
**Correct answer: A**
**Explanation:** Trang 91 định nghĩa Chữ ký số là chuỗi dữ liệu liên kết với thông điệp và thực thể tạo ra, thường dùng để đảm bảo tính toàn vẹn của thông điệp (và xác thực người gửi).

Q34. Trong quá trình tạo chữ ký số, người gửi sử dụng khóa nào?
A. Khóa riêng (Private key) của người gửi.
B. Khóa công khai (Public key) của người gửi.
C. Khóa công khai (Public key) của người nhận.
D. Khóa phiên (Session key).
**Correct answer: A**
**Explanation:** Trang 92 mô tả quá trình ký: Chuỗi đại diện được ký sử dụng khóa riêng (Private key) của người gửi.

Q35. Trong quá trình kiểm tra chữ ký số, người nhận sử dụng khóa nào?
A. Khóa công khai (Public key) của người gửi.
B. Khóa riêng (Private key) của người nhận.
C. Khóa riêng (Private key) của người gửi.
D. Khóa phiên (Session key).
**Correct answer: A**
**Explanation:** Trang 93 mô tả quá trình kiểm tra: Sử dụng khóa công khai (Public key) của người gửi để giải mã chữ ký số (khôi phục chuỗi đại diện MD2).

Q36. Chứng chỉ số (Digital Certificate) dùng để làm gì?
A. Liên kết khóa công khai với thông tin nhận dạng của một thực thể.
B. Mã hóa dữ liệu truyền đi.
C. Lưu trữ khóa riêng an toàn.
D. Tạo ra chữ ký số.
**Correct answer: A**
**Explanation:** Trang 95 định nghĩa Chứng chỉ số là tài liệu điện tử sử dụng chữ ký số để liên kết một khóa công khai và thông tin nhận dạng của một thực thể.

Q37. Tổ chức nào cấp và ký chứng chỉ số?
A. CA (Certificate Authority - Cơ quan cấp chứng chỉ).
B. RA (Registration Authority - Cơ quan đăng ký).
C. VA (Validation Authority - Cơ quan xác nhận).
D. Người dùng cuối.
**Correct answer: A**
**Explanation:** Trang 95 và 97 định nghĩa CA là bên thứ 3 tin cậy, có thẩm quyền cấp và ký (bằng khóa riêng của CA) lên chứng chỉ số.

Q38. PKI (Public Key Infrastructure - Hạ tầng khóa công khai) là gì?
A. Là một tập hợp phần cứng, phần mềm, chính sách, thủ tục để quản lý chứng chỉ số.
B. Là một giải thuật mã hóa khóa công khai cụ thể.
C. Là tên của một loại chứng chỉ số.
D. Là một giao thức trao đổi khóa.
**Correct answer: A**
**Explanation:** Trang 97 định nghĩa PKI là một tập các phần cứng, phần mềm, nhân lực, chính sách và các thủ tục để tạo, quản lý, phân phối, sử dụng, lưu trữ và thu hồi các chứng chỉ số.

Q39. KDC (Key Distribution Center - Trung tâm phân phối khóa) dùng để làm gì?
A. Tạo và phân phối khóa bí mật (khóa phiên) an toàn cho các bên.
B. Lưu trữ khóa công khai của người dùng.
C. Cấp phát chứng chỉ số.
D. Kiểm tra tính hợp lệ của chữ ký số.
**Correct answer: A**
**Explanation:** Trang 101 giới thiệu KDC là một kỹ thuật giải quyết bài toán phân phối khóa bí mật, trong đó KDC tạo và phân phối khóa bí mật an toàn đến các thực thể.

Q40. SSL/TLS là giao thức bảo mật hoạt động ở tầng nào trong mô hình TCP/IP?
A. Nằm giữa tầng Giao vận (Transport) và tầng Ứng dụng (Application).
B. Tầng Mạng (Network/Internet).
C. Tầng Liên kết dữ liệu (Data Link).
D. Tầng Vật lý (Physical).
**Correct answer: A**
**Explanation:** Hình 3.39 (Trang 105) cho thấy SSL/TLS nằm phía trên TCP (Tầng Giao vận) và phía dưới các giao thức ứng dụng như HTTP, FTP, SMTP.

Q41. Giao thức con nào của SSL/TLS chịu trách nhiệm thiết lập phiên làm việc an toàn ban đầu?
A. SSL Handshake Protocol.
B. SSL Record Protocol.
C. SSL Alert Protocol.
D. SSL Change Cipher Spec Protocol.
**Correct answer: A**
**Explanation:** Trang 106 mô tả SSL Handshake Protocol có nhiệm vụ trao đổi thông điệp xác thực và thiết lập các thông số cho phiên làm việc.

Q42. Giao thức con nào của SSL/TLS chịu trách nhiệm vận chuyển dữ liệu ứng dụng một cách an toàn?
A. SSL Record Protocol.
B. SSL Handshake Protocol.
C. SSL Alert Protocol.
D. SSL Change Cipher Spec Protocol.
**Correct answer: A**
**Explanation:** Trang 106 mô tả SSL Record Protocol có nhiệm vụ tạo đường hầm an toàn để chuyển thông tin, đảm bảo bí mật, toàn vẹn và xác thực. Trang 107-108 mô tả quá trình xử lý dữ liệu của nó.

Q43. HTTPS là sự kết hợp của giao thức nào?
A. HTTP + SSL/TLS.
B. HTTP + PGP.
C. HTTP + SET.
D. HTTP + IPSec.
**Correct answer: A**
**Explanation:** Trang 105 giải thích HTTPS = HTTP + SSL/TLS, nghĩa là HTTP chạy trên nền SSL/TLS.

Q44. PGP (Pretty Good Privacy) được sử dụng rộng rãi để bảo mật cho ứng dụng nào?
A. Email và file.
B. Trình duyệt web.
C. Cơ sở dữ liệu.
D. Hệ điều hành.
**Correct answer: A**
**Explanation:** Trang 110 nêu PGP được sử dụng rộng rãi để truyền email và file an toàn.

Q45. Mô hình PGP chỉ đảm bảo tính xác thực (Hình 3.45) sử dụng cơ chế nào?
A. Chữ ký số (Sử dụng hàm băm H và mã hóa bằng khóa riêng PRa).
B. Mã hóa đối xứng (EC).
C. Mã hóa bất đối xứng (EP).
D. Nén dữ liệu (Z).
**Correct answer: A**
**Explanation:** Hình 3.45 (Trang 110) minh họa việc tính hash H(M), sau đó mã hóa hash bằng khóa riêng PRa (ký hiệu EP nhưng dùng khóa riêng là ký) để tạo chữ ký.

Q46. Mô hình PGP chỉ đảm bảo tính bí mật (Hình 3.46) sử dụng cơ chế nào là chính?
A. Mã hóa đối xứng (EC) với khóa phiên Ks và mã hóa bất đối xứng (EP) để gửi Ks.
B. Chỉ sử dụng chữ ký số.
C. Chỉ sử dụng hàm băm.
D. Chỉ sử dụng nén dữ liệu.
**Correct answer: A**
**Explanation:** Hình 3.46 (Trang 111) minh họa thông điệp M được mã hóa bằng mã hóa đối xứng (EC) với khóa phiên Ks. Khóa Ks sau đó được mã hóa bằng khóa công khai của người nhận (PUb) thông qua mã hóa bất đối xứng (EP).

Q47. Hàm Feistel (F) là thành phần cốt lõi trong giải thuật nào?
A. DES.
B. AES.
C. RSA.
D. MD5.
**Correct answer: A**
**Explanation:** Trang 77-78 mô tả cấu trúc 16 vòng lặp của DES sử dụng hàm Feistel (F).

Q48. Giải thuật 3-DES (Triple DES) thực hiện DES mấy lần?
A. 3 lần.
B. 2 lần.
C. 1 lần.
D. 16 lần.
**Correct answer: A**
**Explanation:** Trang 78-79 định nghĩa 3-DES áp dụng DES 3 lần cho mỗi khối dữ liệu.

Q49. Trong AES, ma trận dữ liệu 4x4 (16 byte) được gọi là gì?
A. State (Trạng thái).
B. S-box.
C. Round Key (Khóa vòng).
D. Cipher Block (Khối mã).
**Correct answer: A**
**Explanation:** Trang 79 mô tả AES vận hành dựa trên một ma trận vuông 4x4, được gọi là state (trạng thái).

Q50. Hàm SubBytes trong AES thực hiện thao tác gì?
A. Thay thế mỗi byte trong state bằng một byte khác dựa trên S-box.
B. Dịch vòng các byte trong mỗi hàng của state.
C. Trộn dữ liệu giữa các cột của state.
D. XOR state với khóa vòng.
**Correct answer: A**
**Explanation:** Trang 80 (và 82) mô tả hàm SubBytes thực hiện thay thế phi tuyến tính mỗi byte trong state dựa vào bảng S-box.

---

**Mức độ: Trung bình**

Q51. Tại sao mã hóa khóa đối xứng thường nhanh hơn mã hóa khóa bất đối xứng?
A. Do các phép toán trong thuật toán đối xứng (như XOR, thay thế, hoán vị bit) thường đơn giản và ít tốn tài nguyên tính toán hơn các phép toán trên số lớn (như lũy thừa modulo) trong thuật toán bất đối xứng.
B. Do khóa đối xứng ngắn hơn khóa bất đối xứng.
C. Do giải thuật đối xứng không cần sinh khóa.
D. Do chỉ cần một khóa thay vì hai khóa.
**Correct answer: A**
**Explanation:** Mã hóa đối xứng (DES, AES) dựa trên các phép toán bit/byte đơn giản. Mã hóa bất đối xứng (RSA) dựa trên các phép toán số học phức tạp trên các số rất lớn (ví dụ: m^e mod n), đòi hỏi năng lực tính toán cao hơn đáng kể.

Q52. Nhược điểm lớn nhất của mã hóa khóa đối xứng là gì?
A. Khó khăn trong việc quản lý và phân phối khóa bí mật an toàn, đặc biệt với nhiều người dùng.
B. Tốc độ mã hóa và giải mã chậm.
C. Độ an toàn không cao bằng khóa bất đối xứng.
D. Không thể dùng để tạo chữ ký số.
**Correct answer: A**
**Explanation:** Trang 75 và 100 nhấn mạnh nhược điểm lớn nhất của mã hóa khóa đối xứng là việc quản lý và phân phối khóa bí mật một cách an toàn, đặc biệt khi số lượng người dùng lớn (bài toán n^2 khóa).

Q53. Ưu điểm chính của mã hóa khóa bất đối xứng so với khóa đối xứng là gì?
A. Giải quyết được vấn đề phân phối khóa an toàn (chỉ cần phân phối khóa công khai).
B. Tốc độ mã hóa và giải mã nhanh hơn.
C. Yêu cầu kích thước khóa nhỏ hơn để đạt cùng độ an toàn.
D. Dễ dàng triển khai hơn trong phần cứng.
**Correct answer: A**
**Explanation:** Trang 70 và 83-84 cho thấy ưu điểm nổi bật của mã hóa khóa bất đối xứng là việc quản lý và phân phối khóa đơn giản hơn do chỉ khóa riêng cần giữ bí mật, khóa công khai có thể phổ biến rộng rãi.

Q54. Tại sao hàm băm một chiều (One-way hash function) lại hữu ích trong việc đảm bảo tính toàn vẹn?
A. Vì rất khó (không khả thi về mặt tính toán) để tìm ra thông điệp gốc từ chuỗi băm, và bất kỳ thay đổi nhỏ nào trong thông điệp cũng tạo ra chuỗi băm hoàn toàn khác.
B. Vì hàm băm có thể đảo ngược để lấy lại thông điệp gốc.
C. Vì chuỗi băm luôn ngắn hơn thông điệp gốc.
D. Vì hàm băm sử dụng khóa bí mật.
**Correct answer: A**
**Explanation:** Tính một chiều của hàm băm (trang 87) đảm bảo không thể suy ngược thông điệp. Tính nhạy cảm với thay đổi đầu vào (tính chất khuếch tán/confusion & diffusion) đảm bảo mọi sửa đổi trên thông điệp sẽ bị phát hiện khi so sánh chuỗi băm.

Q55. Mục đích của việc sử dụng nhiều bộ chữ mã trong phương pháp thay thế (Hình 3.9) là gì?
A. Tăng độ khó cho việc phân tích tần suất ký tự, làm tăng độ an toàn so với dùng 1 bộ chữ mã cố định (như Caesar).
B. Giảm kích thước của bản mã.
C. Tăng tốc độ mã hóa.
D. Đơn giản hóa quá trình giải mã.
**Correct answer: A**
**Explanation:** Trang 73 mô tả việc dùng nhiều bộ chữ mã (substitution cipher) làm cho một ký tự ở bản rõ có thể được mã hóa thành các ký tự khác nhau ở bản mã, gây khó khăn cho việc thám mã dựa trên phân tích tần suất xuất hiện của các ký tự.

Q56. Tại sao mã hóa Vernam với one-time pad được coi là mã hóa tuyệt đối an toàn về mặt lý thuyết?
A. Nếu khóa (pad) được tạo ngẫu nhiên thực sự, dài bằng bản rõ, và chỉ sử dụng một lần duy nhất, thì bản mã không chứa thông tin thống kê nào về bản rõ.
B. Vì nó sử dụng phép toán XOR đơn giản.
C. Vì nó được phát minh bởi Vernam.
D. Vì nó yêu cầu khóa rất dài.
**Correct answer: A**
**Explanation:** Mã hóa Vernam/One-time pad (OTP) được chứng minh là an toàn tuyệt đối nếu các điều kiện về khóa (ngẫu nhiên, dùng một lần, dài bằng bản rõ, giữ bí mật tuyệt đối) được thỏa mãn. Khi đó, mọi bản rõ có cùng độ dài đều có thể là kết quả giải mã từ một bản mã cho trước.

Q57. Tại sao DES hiện nay được coi là không an toàn?
A. Do kích thước khóa hiệu dụng (56 bit) quá nhỏ, có thể bị tấn công vét cạn bằng các hệ thống máy tính hiện đại.
B. Do thuật toán có nhiều lỗ hổng logic.
C. Do tốc độ mã hóa quá chậm.
D. Do đã bị thay thế hoàn toàn bởi AES.
**Correct answer: A**
**Explanation:** Trang 76 nêu rõ: "Hiện nay DES được coi là không an toàn do nó có không gian khóa nhỏ, dễ bị vét cạn...". Khóa 56 bit không đủ chống lại sức mạnh tính toán ngày nay.

Q58. Mục đích của hàm mở rộng E (Expansion) trong hàm Feistel của DES là gì?
A. Mở rộng khối dữ liệu 32 bit thành 48 bit để có thể XOR với khóa phụ 48 bit.
B. Giảm kích thước khối dữ liệu để xử lý nhanh hơn.
C. Hoán vị vị trí các bit.
D. Thay thế các bit bằng S-box.
**Correct answer: A**
**Explanation:** Trang 78 mô tả bước E (Expansion) thực hiện mở rộng 32 bit khối đầu vào thành 48 bit, để phù hợp với kích thước của khóa phụ (Subkey) 48 bit cho phép toán XOR tiếp theo.

Q59. S-box trong DES đóng vai trò gì trong việc tạo ra sự an toàn?
A. Là thành phần phi tuyến tính duy nhất, tạo ra sự "nhầm lẫn" (confusion), làm phức tạp mối quan hệ giữa bản rõ, bản mã và khóa.
B. Tăng kích thước dữ liệu (Expansion).
C. Hoán vị vị trí các bit (Permutation).
D. Giảm kích thước dữ liệu.
**Correct answer: A**
**Explanation:** Trang 78 mô tả S-box (Substitution) thực hiện phép chuyển đổi phi tuyến tính. Đây là cốt lõi tạo ra sự an toàn cho DES, chống lại các phương pháp thám mã tuyến tính và vi phân.

Q60. Tại sao 3-DES lại an toàn hơn DES đáng kể?
A. Do tăng kích thước khóa hiệu dụng lên 112 bit hoặc 168 bit, làm tấn công vét cạn trở nên khó khăn hơn rất nhiều.
B. Do thực hiện mã hóa 3 lần nên thuật toán phức tạp hơn.
C. Do sử dụng các S-box khác với DES.
D. Do được chuẩn hóa bởi NIST.
**Correct answer: A**
**Explanation:** Trang 78-79 cho thấy 3-DES sử dụng 2 hoặc 3 khóa DES độc lập, nâng tổng kích thước khóa hiệu dụng lên 112 hoặc 168 bit, đủ lớn để chống lại tấn công vét cạn hiện nay.

Q61. Hàm ShiftRows trong AES đóng góp vào tính an toàn như thế nào?
A. Tạo ra sự "khuếch tán" (diffusion) bằng cách dịch chuyển dữ liệu giữa các cột khác nhau trong ma trận state qua các vòng.
B. Thay thế byte phi tuyến tính.
C. Trộn dữ liệu trong cùng một cột.
D. Kết hợp khóa vòng vào state.
**Correct answer: A**
**Explanation:** Hàm ShiftRows (trang 80, 82) dịch chuyển các byte trong các hàng (trừ hàng đầu) đi các số bước khác nhau. Thao tác này giúp lan tỏa ảnh hưởng của một byte đầu vào ra nhiều byte đầu ra qua các vòng, đạt được tính khuếch tán.

Q62. Hàm MixColumns trong AES đóng góp vào tính an toàn như thế nào?
A. Tạo ra sự "khuếch tán" (diffusion) bằng cách trộn dữ liệu giữa các byte trong cùng một cột.
B. Thay thế byte phi tuyến tính (đó là SubBytes).
C. Dịch chuyển dữ liệu giữa các hàng (đó là ShiftRows).
D. Cộng khóa vòng vào state.
**Correct answer: A**
**Explanation:** Hàm MixColumns (trang 80, 82) thực hiện phép nhân ma trận trên từng cột của state, làm cho mỗi byte đầu ra phụ thuộc vào cả 4 byte đầu vào của cột đó, tăng cường tính khuếch tán trong cột.

Q63. Tại sao trong quá trình giải mã AES, các hàm InvShiftRows và InvMixColumns được sử dụng?
A. Vì chúng là các hàm ngược của ShiftRows và MixColumns, cần thiết để đảo ngược quá trình mã hóa.
B. Để tăng cường độ an toàn cho quá trình giải mã.
C. Để làm cho quá trình giải mã tương tự quá trình mã hóa.
D. Do yêu cầu của chuẩn FIPS.
**Correct answer: A**
**Explanation:** Trang 83 mô tả quá trình giải mã AES sử dụng các hàm đảo ngược InvSubBytes, InvShiftRows, InvMixColumns để hoàn tác các bước tương ứng trong quá trình mã hóa.

Q64. Nếu sử dụng RSA để mã hóa và ký số, khóa nào được dùng để mã hóa và khóa nào được dùng để ký?
A. Mã hóa dùng khóa công khai của người nhận; Ký dùng khóa riêng của người gửi.
B. Mã hóa dùng khóa riêng của người gửi; Ký dùng khóa công khai của người nhận.
C. Cả mã hóa và ký đều dùng khóa công khai.
D. Cả mã hóa và ký đều dùng khóa riêng.
**Correct answer: A**
**Explanation:** Trang 93 phân biệt rõ: Để mã hóa (đảm bảo bí mật cho người nhận), người gửi dùng khóa công khai của người nhận. Để ký (xác thực người gửi), người gửi dùng khóa riêng của chính mình.

Q65. Tại sao cần phải băm thông điệp trước khi tạo chữ ký số bằng RSA hoặc DSA?
A. Để giảm kích thước dữ liệu cần ký (ký trên chuỗi hash ngắn thay vì thông điệp dài), tăng tốc độ và hiệu quả; đồng thời đảm bảo tính toàn vẹn.
B. Để tăng độ dài của chữ ký số.
C. Để mã hóa thông điệp cùng lúc với việc ký.
D. Để che giấu nội dung thông điệp.
**Correct answer: A**
**Explanation:** Ký trực tiếp lên thông điệp dài sẽ rất chậm (do dùng mã hóa bất đối xứng) và tạo ra chữ ký rất lớn. Ký trên chuỗi băm (kích thước cố định, ngắn) hiệu quả hơn nhiều. Đồng thời, vì hash đại diện cho toàn vẹn thông điệp, ký trên hash cũng đảm bảo tính toàn vẹn.

Q66. Nội dung chính của một chứng chỉ số X.509 bao gồm những thông tin gì?
A. Thông tin chủ thể, khóa công khai chủ thể, thông tin CA, chữ ký số của CA, thời hạn hiệu lực.
B. Chỉ có khóa công khai và khóa riêng.
C. Chỉ có tên chủ thể và chữ ký số.
D. Chỉ có thuật toán mã hóa và hàm băm.
**Correct answer: A**
**Explanation:** Trang 95-96 liệt kê các trường thông tin chính của chứng chỉ X.509, bao gồm Serial Number, Subject, Signature Algorithm, Issuer, Valid-From, Valid-To, Key-Usage, Public Key, Thumbprint,... và quan trọng nhất là chữ ký của CA lên toàn bộ thông tin đó.

Q67. Vai trò của RA (Registration Authority) trong PKI là gì?
A. Tiếp nhận và kiểm tra thông tin nhận dạng của người dùng yêu cầu cấp chứng chỉ, trước khi chuyển cho CA.
B. Cấp phát chứng chỉ số trực tiếp cho người dùng.
C. Lưu trữ và phân phối chứng chỉ số.
D. Kiểm tra tính hợp lệ của chứng chỉ số đã cấp.
**Correct answer: A**
**Explanation:** Trang 97 định nghĩa RA là bộ phận tiếp nhận, kiểm tra thông tin nhận dạng của người dùng theo yêu cầu của CA. RA không cấp chứng chỉ mà chỉ xác minh ban đầu.

Q68. So sánh KDC và KTC trong việc phân phối khóa bí mật.
A. KDC tự tạo và phân phối khóa; KTC chỉ dịch (mã hóa lại) khóa do một bên tạo ra để gửi cho bên kia.
B. KTC an toàn hơn KDC.
C. KDC dùng khóa công khai, KTC dùng khóa bí mật.
D. KDC chỉ dùng cho 2 người, KTC dùng cho nhiều người.
**Correct answer: A**
**Explanation:** Trang 101 (KDC) và 102 (KTC) mô tả hoạt động. KDC (Hình 3.37) tự tạo khóa K và gửi cho A, B. KTC (Hình 3.38) nhận khóa K do A tạo, giải mã bằng KAT rồi mã hóa lại bằng KBT để gửi cho B.

Q69. Tại sao việc phân phối khóa công khai cũng cần đảm bảo tính xác thực (authentic public keys)?
A. Để ngăn chặn kẻ tấn công thay thế khóa công khai thật bằng khóa giả mạo (thuộc về kẻ tấn công), dẫn đến tấn công Man-in-the-Middle.
B. Để đảm bảo khóa công khai luôn là số nguyên tố.
C. Để khóa công khai có thể sử dụng được lâu dài.
D. Để giảm kích thước của khóa công khai.
**Correct answer: A**
**Explanation:** Trang 103 nhấn mạnh việc phân phối khóa công khai phải đảm bảo tính xác thực. Nếu người dùng nhận phải khóa công khai giả mạo của kẻ tấn công (mà nghĩ là của đối tác), họ sẽ mã hóa thông tin bằng khóa đó và gửi đi, kẻ tấn công có thể giải mã bằng khóa riêng tương ứng.

Q70. Quá trình Handshake trong SSL/TLS nhằm đạt được những mục tiêu chính nào?
A. Xác thực máy chủ (và tùy chọn máy khách), thỏa thuận bộ mã hóa, trao đổi khóa phiên.
B. Chỉ vận chuyển dữ liệu ứng dụng.
C. Chỉ gửi thông báo lỗi.
D. Chỉ thay đổi bộ mã hóa đang sử dụng.
**Correct answer: A**
**Explanation:** Trang 106 (mục a) liệt kê các nhiệm vụ của quá trình khởi tạo phiên (Handshake) bao gồm: (1) xác thực thông tin nhận dạng, (2) đàm phán thống nhất bộ mã hóa, (3) trao đổi khóa và thông số khác.

Q71. Trong SSL/TLS Handshake (Hình 3.42), Client Key Exchange dùng để làm gì?
A. Client gửi khóa phiên (hoặc vật liệu để tạo khóa phiên) đã được mã hóa bằng khóa công khai của Server.
B. Server gửi khóa phiên cho Client.
C. Client yêu cầu Server gửi chứng chỉ.
D. Hai bên trao đổi thông điệp "Finished".
**Correct answer: A**
**Explanation:** Bước 4 trong Hình 3.42 (trang 107) là "Client key exchange". Client sinh khóa bí mật (khóa phiên), mã hóa nó bằng khóa công khai của Server (lấy từ chứng chỉ Server) và gửi cho Server.

Q72. Giao thức SET (Secure Electronic Transaction) được thiết kế chủ yếu cho loại giao dịch nào?
A. Thanh toán điện tử sử dụng thẻ tín dụng.
B. Truyền file an toàn qua mạng.
C. Đăng nhập vào hệ thống từ xa.
D. Gửi email bảo mật.
**Correct answer: A**
**Explanation:** Trang 108 mô tả SET là giao thức cho phép thanh toán điện tử an toàn sử dụng thẻ tín dụng.

Q73. PGP sử dụng kết hợp mã hóa đối xứng và bất đối xứng như thế nào để đảm bảo bí mật (Hình 3.46)?
A. Dùng mã hóa đối xứng (nhanh) để mã hóa thông điệp lớn; dùng mã hóa bất đối xứng (chậm hơn nhưng tiện phân phối khóa) để mã hóa khóa đối xứng (ngắn).
B. Chỉ dùng mã hóa đối xứng.
C. Chỉ dùng mã hóa bất đối xứng.
D. Dùng mã hóa đối xứng cho khóa, mã hóa bất đối xứng cho thông điệp.
**Correct answer: A**
**Explanation:** Đây là kỹ thuật mã hóa lai (hybrid encryption) phổ biến. Thông điệp M (thường lớn) được mã hóa bằng thuật toán đối xứng nhanh với khóa phiên Ks (ngẫu nhiên, ngắn). Khóa Ks sau đó được mã hóa bằng khóa công khai của người nhận (dùng RSA/ElGamal) và gửi kèm bản mã của M. Người nhận dùng khóa riêng giải mã Ks, rồi dùng Ks giải mã M.

Q74. Hàm băm MD5 và SHA1 hiện nay có còn được coi là an toàn cho các ứng dụng đòi hỏi chống xung đột (collision resistance) như chữ ký số không?
A. Không, cả MD5 và SHA1 đều đã tìm thấy cách tạo xung đột (collision), không nên dùng cho chữ ký số.
B. Có, cả hai vẫn rất an toàn.
C. Chỉ MD5 không an toàn, SHA1 vẫn an toàn.
D. Chỉ SHA1 không an toàn, MD5 vẫn an toàn.
**Correct answer: A**
**Explanation:** Trang 89 đề cập MD5 không còn được khuyến nghị. Thực tế, các cuộc tấn công tìm xung đột hiệu quả đã được chứng minh cho cả MD5 và SHA1, khiến chúng không còn đủ an toàn cho các ứng dụng như tạo chữ ký số, nơi tính chống xung đột là cực kỳ quan trọng. Các chuẩn mới hơn như SHA-256, SHA-3 được khuyến nghị.

Q75. Tại sao cần phải có cơ chế thu hồi chứng chỉ số (Certificate Revocation)?
A. Vì khóa riêng tương ứng với chứng chỉ có thể bị lộ, hoặc thông tin trên chứng chỉ không còn đúng.
B. Vì chứng chỉ số chiếm nhiều dung lượng lưu trữ.
C. Vì CA muốn cấp chứng chỉ mới cho người dùng.
D. Vì người dùng không muốn sử dụng chứng chỉ đó nữa.
**Correct answer: A**
**Explanation:** Nếu khóa riêng bị lộ, kẻ gian có thể giả mạo chủ thể. Nếu thông tin thay đổi (vd: nhân viên nghỉ việc), chứng chỉ không còn giá trị đại diện. Do đó, cần cơ chế (như CRL, OCSP) để thông báo rằng một chứng chỉ không còn đáng tin cậy trước ngày hết hạn.

Q76. Phân phối khóa điểm-điểm (Hình 3.36) có nhược điểm gì khi số lượng người dùng lớn?
A. Yêu cầu số lượng khóa cần quản lý và kênh phân phối an toàn tăng theo cấp số nhân (n^2), không khả thi.
B. Tốc độ phân phối khóa chậm.
C. Độ an toàn thấp.
D. Chỉ dùng được cho khóa công khai.
**Correct answer: A**
**Explanation:** Trang 100-101 phân tích bài toán n^2 khóa. Phân phối điểm-điểm yêu cầu mỗi cặp người dùng phải có kênh an toàn riêng để trao đổi khóa bí mật, dẫn đến chi phí và độ phức tạp quản lý cực lớn khi n lớn.

Q77. Trong quá trình khởi tạo SSL/TLS (Hình 3.42), tại sao Server thường gửi chứng chỉ của mình cho Client?
A. Để Client có thể xác thực danh tính của Server và lấy khóa công khai của Server để mã hóa khóa phiên gửi lại.
B. Để Client kiểm tra xem Server có đang hoạt động hay không.
C. Để Client lưu lại thông tin của Server cho lần kết nối sau.
D. Để Server yêu cầu Client cung cấp chứng chỉ.
**Correct answer: A**
**Explanation:** Bước 2 (trang 107) Server gửi "server hello", bộ mã hóa và chứng chỉ. Chứng chỉ này chứa khóa công khai của Server và thông tin đã được CA xác thực. Client dùng nó để (1) kiểm tra danh tính Server và (2) mã hóa khóa bí mật ở bước Client Key Exchange.

Q78. So sánh cách PGP (Hình 3.47) và SSL/TLS (Hình 3.43) đảm bảo tính toàn vẹn và xác thực dữ liệu.
A. PGP dùng chữ ký số (hash rồi mã hóa bằng khóa riêng); SSL/TLS dùng MAC (hash với khóa phiên đối xứng).
B. Cả hai đều dùng chữ ký số.
C. Cả hai đều dùng MAC.
D. PGP không đảm bảo toàn vẹn, SSL/TLS thì có.
**Correct answer: A**
**Explanation:** Hình 3.47 (và 3.45) cho thấy PGP sử dụng cơ chế ký bằng khóa riêng (bất đối xứng). Hình 3.43 (trang 108) mô tả SSL Record thêm MAC (tính toán bằng hàm băm với khóa bí mật đối xứng - khóa phiên) để đảm bảo toàn vẹn và xác thực.

Q79. Mục đích của trường Key-Usage trong chứng chỉ số X.509 là gì?
A. Chỉ định các mục đích sử dụng hợp lệ cho khóa công khai (ví dụ: chỉ ký, chỉ mã hóa, hay cả hai).
B. Cho biết kích thước của khóa công khai.
C. Xác định thuật toán tạo khóa.
D. Lưu trữ dấu vân tay của khóa.
**Correct answer: A**
**Explanation:** Trang 96 liệt kê trường Key-Usage: Mục đích sử dụng khóa (chữ ký số, mã hóa,...). Điều này giúp giới hạn phạm vi sử dụng khóa, tăng cường an ninh.

Q80. Tại sao việc quản lý vòng đời chứng chỉ số (cấp phát, sử dụng, gia hạn, thu hồi) lại quan trọng trong PKI?
A. Để đảm bảo tính tin cậy, hợp lệ và an toàn của các chứng chỉ và hạ tầng PKI theo thời gian.
B. Để tăng doanh thu cho các nhà cung cấp CA.
C. Để giảm số lượng chứng chỉ cần quản lý.
D. Để đơn giản hóa quy trình cho người dùng cuối.
**Correct answer: A**
**Explanation:** Quản lý vòng đời chứng chỉ (cấp, gia hạn, thu hồi...) là cốt lõi của PKI (trang 97). Nó đảm bảo rằng chỉ các chứng chỉ hợp lệ, chưa bị lộ khóa riêng, thông tin còn chính xác mới được tin cậy và sử dụng, duy trì sự an toàn của toàn bộ hệ thống dựa trên PKI.

---

**Mức độ: Khó**

Q81. Phân tích ưu và nhược điểm của việc sử dụng KDC so với KTC trong phân phối khóa bí mật.
A. Ưu KDC: Đơn giản hơn cho các bên tham gia (không cần tạo khóa). Nhược KDC: Phụ thuộc hoàn toàn vào KDC để tạo khóa, KDC là điểm tấn công trung tâm. Ưu KTC: Cho phép sinh khóa phân tán, giảm tải cho trung tâm. Nhược KTC: Phức tạp hơn cho bên khởi tạo (phải tự tạo khóa).
B. KDC nhanh hơn KTC nhưng kém an toàn hơn.
C. KTC chỉ dùng cho mạng nhỏ, KDC cho mạng lớn.
D. KDC không cần khóa dài hạn, KTC thì cần.
**Correct answer: A**
**Explanation:** KDC (trang 101) tập trung việc tạo khóa, đơn giản cho A và B nhưng tạo điểm lỗi/tấn công duy nhất. KTC (trang 102) cho phép A tự tạo khóa, giảm phụ thuộc vào T nhưng quy trình phức tạp hơn một chút. Cả hai đều giải quyết bài toán n^2 khóa và yêu cầu các bên có khóa dài hạn chia sẻ với trung tâm.

Q82. Giải thích tại sao trong RSA, việc chọn hai số nguyên tố p và q có kích thước gần bằng nhau (ví dụ cùng 1024 bit) lại quan trọng hơn việc chọn một số rất lớn và một số rất nhỏ (ví dụ 2047 bit và 1 bit - tức là số 2)?
A. Nếu một thừa số (ví dụ q=2) quá nhỏ, việc phân tích n = p*q thành thừa số trở nên tầm thường (chỉ cần thử chia cho các số nguyên tố nhỏ), phá vỡ độ an toàn của RSA.
B. Chọn p, q gần bằng nhau giúp tính toán module n nhanh hơn.
C. Chọn p, q gần bằng nhau giúp sinh khóa e dễ dàng hơn.
D. Chọn p, q gần bằng nhau làm cho khóa d nhỏ hơn.
**Correct answer: A**
**Explanation:** Độ an toàn của RSA dựa trên việc khó phân tích n thành p và q. Nếu một trong hai số, ví dụ q, rất nhỏ, kẻ tấn công có thể dễ dàng tìm ra nó bằng cách thử chia n cho các số nguyên tố nhỏ, từ đó tìm ra p=n/q và phá vỡ hệ thống. Do đó, p và q cần phải đủ lớn và có kích thước tương đương nhau (trang 85, mục e).

Q83. So sánh giải thuật chữ ký số DSA và RSA. Tại sao DSA ký nhanh hơn nhưng kiểm tra chậm hơn RSA?
A. DSA: Ký liên quan đến phép toán modulo q (nhỏ hơn), kiểm tra liên quan đến lũy thừa modulo p (lớn). RSA: Cả ký và kiểm tra đều là lũy thừa modulo n (lớn, tương đương p). Phép toán modulo số nhỏ nhanh hơn.
B. DSA sử dụng hàm băm nhanh hơn RSA.
C. RSA yêu cầu khóa dài hơn DSA.
D. Thuật toán sinh số ngẫu nhiên k trong DSA nhanh hơn nhiều so với RSA.
**Correct answer: A**
**Explanation:** Trang 94 mô tả DSA: bước ký tính r, s phụ thuộc modulo q (thường nhỏ, vd 160-256 bit). Bước kiểm tra tính v liên quan đến lũy thừa modulo p (lớn, vd 1024-3072 bit). RSA (trang 93-94) cả ký (c=m^d mod n) và kiểm tra (m=c^e mod n) đều là lũy thừa modulo n (lớn). Do đó DSA ký nhanh hơn (vì q nhỏ) nhưng kiểm tra chậm hơn (vì p lớn) so với RSA (modulo n).

Q84. Trong các phương pháp phân phối khóa công khai, tại sao "Cây xác thực khóa công khai" (Tree authentication of public keys) lại hiệu quả hơn việc lưu trữ đơn thuần trong một danh bạ phẳng?
A. Cây xác thực (ví dụ Merkle Tree) cho phép kiểm tra sự tồn tại và tính toàn vẹn của một khóa công khai một cách hiệu quả mà không cần tải về toàn bộ danh bạ, chỉ cần một đường dẫn xác thực ngắn.
B. Cây xác thực giúp tìm kiếm khóa công khai nhanh hơn.
C. Cây xác thực sử dụng ít dung lượng lưu trữ hơn.
D. Cây xác thực cho phép nhiều CA cùng quản lý.
**Correct answer: A**
**Explanation:** Trang 104 đề cập "cây xác thực khóa công khai" là một phương pháp phổ biến cho danh mục công cộng. Cơ chế này (thường dùng cấu trúc cây băm Merkle) cho phép một người dùng chứng minh khóa của mình có trong danh bạ (được CA gốc xác nhận) bằng cách chỉ cung cấp một số nút hash trên đường đi từ lá đến gốc, hiệu quả hơn nhiều so với việc yêu cầu người kiểm tra phải có toàn bộ danh bạ.

Q85. Phân tích vai trò của thông điệp "Change Cipher Spec" trong SSL/TLS Handshake.
A. Thông điệp này báo hiệu rằng bên gửi sẽ bắt đầu sử dụng bộ mã hóa và khóa phiên vừa được thỏa thuận để mã hóa các thông điệp tiếp theo (như thông điệp "Finished").
B. Thông điệp này dùng để thay đổi địa chỉ IP hoặc cổng của kết nối.
C. Thông điệp này chứa chứng chỉ số của client hoặc server.
D. Thông điệp này báo cáo một lỗi xảy ra trong quá trình handshake.
**Correct answer: A**
**Explanation:** Trang 106 đề cập giao thức này thiết lập việc sử dụng bộ mã hóa đã thỏa thuận. Trong luồng handshake (Hình 3.42), sau khi các khóa và bộ mã hóa được thống nhất (sau Client Key Exchange), cả Client và Server đều gửi Change Cipher Spec trước khi gửi thông điệp "Finished" (đã được mã hóa bằng khóa và thuật toán mới).

Q86. Tại sao PGP lại được thiết kế để hoạt động tốt với email, một môi trường thường không có kết nối trực tuyến liên tục giữa người gửi và người nhận?
A. PGP thực hiện mã hóa/ký hoàn toàn tại máy người gửi và giải mã/kiểm tra tại máy người nhận, không yêu cầu tương tác trực tuyến theo thời gian thực giữa hai bên trong quá trình xử lý thông điệp.
B. PGP sử dụng các máy chủ trung gian để lưu trữ và chuyển tiếp thông điệp.
C. PGP có khả năng nén dữ liệu rất tốt, phù hợp với đường truyền chậm của email.
D. PGP tích hợp sẵn vào mọi chương trình email client.
**Correct answer: A**
**Explanation:** Các mô hình hoạt động của PGP (trang 110-112) đều mô tả các bước xử lý (nén, ký, mã hóa) diễn ra độc lập ở phía người gửi. Kết quả là một khối dữ liệu (email hoặc file) có thể gửi đi. Người nhận khi nhận được sẽ thực hiện các bước ngược lại (giải mã, kiểm tra ký, giải nén). Quá trình này không đòi hỏi hai bên phải online cùng lúc, phù hợp với bản chất store-and-forward của email.

Q87. Giải thích cơ chế hoạt động cơ bản của một Trung tâm dịch khóa (KTC - Key Translation Center). Nó khác KDC ở điểm nào về nguồn gốc khóa phiên?
A. KTC không tự tạo khóa phiên. Nó nhận khóa phiên do một bên (vd: A) tạo ra, giải mã bằng khóa dài hạn của A (KAT), rồi mã hóa lại bằng khóa dài hạn của B (KBT) và gửi cho B. KDC thì tự tạo khóa phiên.
B. KTC tạo khóa phiên, KDC dịch khóa phiên.
C. KTC sử dụng khóa công khai, KDC sử dụng khóa bí mật.
D. KTC chỉ chuyển tiếp khóa, không mã hóa lại.
**Correct answer: A**
**Explanation:** Trang 102-103 mô tả KTC. A tạo khóa K, mã hóa bằng KAT gửi cho T. T giải mã bằng KAT, lấy được K. T mã hóa K bằng KBT gửi cho B. Như vậy, khóa K do A tạo (sinh khóa phân tán), T chỉ đóng vai trò "dịch" (mã hóa lại) khóa đó cho B. KDC thì tự tạo khóa K (sinh khóa tập trung).

Q88. Tại sao trong thủ tục sinh khóa con của DES (Hình 3.15), chỉ có 48 bit được chọn từ 56 bit sau khi dịch vòng (PC2)?
A. Để phù hợp với kích thước yêu cầu (48 bit) của hàm Feistel F (cụ thể là để XOR với 48 bit dữ liệu mở rộng từ bước E).
B. Để tăng độ an toàn bằng cách loại bỏ các bit yếu.
C. Để giảm độ phức tạp tính toán.
D. Do giới hạn của phần cứng thời đó.
**Correct answer: A**
**Explanation:** Hàm Feistel F (Hình 3.17, trang 78) yêu cầu một khóa phụ (Subkey) 48 bit để XOR với kết quả 48 bit từ bước E (Expansion). Do đó, phép hoán vị chọn lọc PC2 (Permuted Choice 2) được thiết kế để chọn ra 48 bit từ 56 bit đã dịch vòng, tạo ra khóa phụ có kích thước phù hợp.

Q89. Phân tích mối quan hệ giữa các hàm SubBytes, ShiftRows, MixColumns trong việc đảm bảo tính confusion và diffusion của AES.
A. SubBytes (thay thế phi tuyến) là nguồn chính tạo confusion. ShiftRows và MixColumns (hoán vị và trộn tuyến tính) cùng nhau tạo ra diffusion mạnh mẽ, lan tỏa ảnh hưởng của SubBytes ra toàn bộ state qua các vòng.
B. Cả 3 hàm đều chỉ tạo confusion.
C. Cả 3 hàm đều chỉ tạo diffusion.
D. SubBytes và ShiftRows tạo confusion, MixColumns tạo diffusion.
**Correct answer: A**
**Explanation:** SubBytes là thao tác phi tuyến duy nhất, làm phức tạp mối quan hệ đầu vào-đầu ra (confusion). ShiftRows (hoán vị giữa các cột) và MixColumns (trộn trong từng cột) là các phép biến đổi tuyến tính giúp sự thay đổi ở một byte lan tỏa nhanh chóng ra nhiều byte khác trong state qua các vòng lặp (diffusion). Sự kết hợp này tạo nên độ an toàn cao cho AES.

Q90. Khái niệm "Không gian khóa" (Keyspace) có ý nghĩa gì đối với độ an toàn của một hệ mã hóa?
A. Keyspace càng lớn thì việc tấn công bằng phương pháp thử toàn bộ khóa (brute force/vét cạn) càng tốn nhiều thời gian và tài nguyên, do đó hệ mã hóa càng an toàn hơn trước kiểu tấn công này.
B. Keyspace càng lớn thì mã hóa càng nhanh.
C. Keyspace không ảnh hưởng đến độ an toàn.
D. Keyspace chỉ quan trọng đối với mã hóa bất đối xứng.
**Correct answer: A**
**Explanation:** Trang 67 định nghĩa Keyspace là tổng số khóa có thể có. Độ lớn của keyspace quyết định trực tiếp độ khó của tấn công vét cạn. Ví dụ, DES với keyspace 2^56 (trang 76) bị coi là nhỏ và không an toàn, trong khi AES với keyspace 2^128, 2^192, 2^256 (trang 79) được coi là an toàn trước tấn công vét cạn hiện nay.

Q91. Tại sao phương pháp mã hóa sách/khóa chạy (Book/Running Key Cipher) lại không an toàn trong thực tế mặc dù có vẻ phức tạp?
A. Vì khóa (nội dung cuốn sách) không thực sự ngẫu nhiên và có cấu trúc ngôn ngữ, dễ bị tấn công dựa trên thống kê và ngữ cảnh nếu có đủ bản mã.
B. Vì quá trình tra cứu sách rất chậm.
C. Vì cần phải mang theo sách rất bất tiện.
D. Vì dễ bị mất sách chứa khóa.
**Correct answer: A**
**Explanation:** Trang 74 mô tả phương pháp này. Mặc dù khóa có vẻ dài và thay đổi, nhưng nó lấy từ văn bản thực tế (sách). Văn bản này có các đặc tính thống kê của ngôn ngữ tự nhiên (tần suất chữ cái, cặp chữ, từ phổ biến...), không phải là chuỗi ngẫu nhiên như one-time pad. Nếu kẻ tấn công đoán được cuốn sách hoặc có đủ bản mã, họ có thể sử dụng phân tích thống kê để phá mã.

Q92. Giải thích tại sao HMAC (Hash-based Message Authentication Code) lại an toàn hơn việc chỉ băm thông điệp ghép với khóa bí mật (ví dụ: H(key || message))?
A. HMAC sử dụng cấu trúc lồng nhau (hai lần băm với khóa được xử lý qua ipad/opad), được chứng minh là có khả năng chống lại các tấn công mở rộng độ dài (length extension attacks) và các tấn công khác mà các cấu trúc đơn giản hơn có thể mắc phải.
B. HMAC sử dụng thuật toán băm mạnh hơn.
C. HMAC tạo ra chuỗi MAC dài hơn.
D. HMAC không cần khóa bí mật.
**Correct answer: A**
**Explanation:** Mặc dù HMAC không được mô tả chi tiết, nhưng nó là một dạng MAC phổ biến thuộc nhóm hàm băm có khóa (Hình 3.27). Cấu trúc H(key || M) hoặc H(M || key) đơn giản có thể bị tấn công length extension (nếu biết H(M) có thể tính H(M||M')). Cấu trúc của HMAC (sử dụng ipad, opad và hai bước băm) được thiết kế đặc biệt để chống lại các kiểu tấn công này, mang lại độ an toàn cao hơn khi dùng hàm băm để tạo MAC.

Q93. So sánh độ phức tạp và yêu cầu tài nguyên giữa việc triển khai PKI đầy đủ và việc chỉ sử dụng PGP cho liên lạc cá nhân/nhóm nhỏ.
A. PKI (CA, RA, VA, CD...) đòi hỏi hạ tầng phức tạp, tốn kém, quy trình chặt chẽ, phù hợp cho tổ chức lớn. PGP dựa trên "mạng lưới tin cậy" (web of trust) hoặc trao đổi khóa trực tiếp, đơn giản hơn, ít tốn kém hơn, phù hợp cho cá nhân/nhóm nhỏ.
B. PGP phức tạp và tốn kém hơn PKI.
C. PKI không cần quản lý khóa, PGP thì cần.
D. Cả hai có độ phức tạp và chi phí tương đương.
**Correct answer: A**
**Explanation:** PKI (trang 97-99) là một hạ tầng hoàn chỉnh với nhiều thành phần và quy trình nghiêm ngặt. PGP (trang 109-112) thường dựa vào việc người dùng tự quản lý khóa, tự xác minh khóa của người khác thông qua mô hình web of trust (ký chéo lên khóa của nhau) hoặc trao đổi trực tiếp, linh hoạt hơn nhưng quy mô quản lý tập trung kém hơn PKI.

Q94. Tại sao việc sử dụng cùng một cặp khóa RSA cho cả mã hóa và ký số lại tiềm ẩn rủi ro bảo mật hơn so với việc dùng các cặp khóa riêng biệt?
A. Việc sử dụng cùng khóa cho nhiều mục đích khác nhau làm tăng bề mặt tấn công và có thể tạo ra các mối liên hệ không mong muốn giữa các giao thức, tiềm ẩn nguy cơ bị tấn công (ví dụ: tấn công Bleichenbacher vào PKCS#1 v1.5). Dùng khóa riêng biệt cho từng mục đích giúp cô lập rủi ro.
B. Gây khó khăn cho việc quản lý khóa.
C. Làm giảm tốc độ xử lý.
D. Vi phạm chuẩn X.509.
**Correct answer: A**
**Explanation:** Về nguyên tắc, việc tái sử dụng khóa cho các mục đích mật mã khác nhau là không được khuyến khích. Mặc dù RSA về lý thuyết cho phép, nhưng các lỗ hổng có thể xuất hiện khi một khóa được dùng trong các ngữ cảnh khác nhau (ví dụ: cách đệm dữ liệu khác nhau cho mã hóa và ký). Các cuộc tấn công thực tế đã chứng minh điều này. Do đó, thực hành tốt nhất là dùng các cặp khóa riêng cho mã hóa và ký.

Q95. Phân tích vai trò của số nonce (number used once) hoặc các giá trị ngẫu nhiên trong các giao thức bảo mật như SSL/TLS Handshake.
A. Giúp chống lại các cuộc tấn công phát lại (replay attacks), đảm bảo rằng mỗi phiên làm việc là duy nhất và thông điệp không thể bị ghi lại và sử dụng lại một cách độc hại.
B. Dùng làm khóa mã hóa đối xứng.
C. Dùng để xác định phiên bản giao thức.
D. Dùng để nén dữ liệu hiệu quả hơn.
**Correct answer: A**
**Explanation:** Trong SSL/TLS Handshake (Hình 3.42), cả client hello và server hello đều chứa giá trị ngẫu nhiên (random). Các giá trị này được sử dụng trong quá trình sinh khóa phiên và để chống tấn công phát lại. Kẻ tấn công không thể ghi lại một phiên giao dịch cũ và phát lại vì các giá trị ngẫu nhiên sẽ khác, dẫn đến khóa phiên khác và các thông điệp mã hóa/MAC sẽ không hợp lệ.

Q96. Mô hình mã hóa khối ECB (Electronic Codebook) có nhược điểm gì và tại sao nó không được khuyến khích sử dụng?
A. Mỗi khối bản rõ giống nhau luôn được mã hóa thành cùng một khối bản mã, làm lộ mẫu thông tin trong bản rõ, không đảm bảo tính bí mật ngữ nghĩa.
B. Tốc độ mã hóa rất chậm.
C. Yêu cầu khóa phải thay đổi sau mỗi khối.
D. Không thể giải mã được.
**Correct answer: A**
**Explanation:** Mặc dù các chế độ hoạt động (modes of operation) không được mô tả chi tiết, ECB là chế độ đơn giản nhất, mã hóa từng khối độc lập. Nhược điểm chí mạng của nó là bảo toàn mẫu (pattern preservation), ví dụ ảnh bitmap mã hóa bằng ECB vẫn nhìn ra hình dạng gốc. Các chế độ khác như CBC, CTR, GCM sử dụng vector khởi tạo (IV) hoặc cơ chế phản hồi để khắc phục điều này.

Q97. Hàm băm cần có những tính chất bảo mật cơ bản nào để được coi là an toàn?
A. Tính kháng tiền ảnh (Preimage resistance), Tính kháng tiền ảnh thứ hai (Second preimage resistance), Tính kháng xung đột (Collision resistance).
B. Tính đối xứng, Tính tuyến tính, Tính đảo ngược.
C. Tính bí mật, Tính toàn vẹn, Tính sẵn dùng.
D. Kích thước đầu ra cố định, Dễ tính toán, Nén dữ liệu.
**Correct answer: A**
**Explanation:** Ba tính chất cơ bản của hàm băm mật mã là: (1) Kháng tiền ảnh: Khó tìm M nếu biết H(M). (2) Kháng tiền ảnh thứ hai: Khó tìm M' khác M sao cho H(M') = H(M) nếu biết M. (3) Kháng xung đột: Khó tìm hai M và M' khác nhau bất kỳ sao cho H(M) = H(M'). (MD5, SHA1 yếu ở tính chất 3).

Q98. Giải thích tại sao việc lựa chọn tham số e (số mũ công khai) trong RSA thường là các số nhỏ như 3 hoặc 65537 (2^16+1)?
A. Chọn e nhỏ giúp tăng tốc độ mã hóa (hoặc kiểm tra chữ ký) vì phép toán c = m^e mod n sẽ cần ít phép nhân hơn. e=65537 là số Fermat F4, có dạng nhị phân thưa (ít bit 1) cũng giúp tối ưu hóa phép lũy thừa.
B. Chọn e nhỏ giúp tăng tốc độ giải mã (hoặc ký).
C. Chọn e nhỏ làm cho khóa d lớn hơn, an toàn hơn.
D. Do yêu cầu của chuẩn PKCS#1.
**Correct answer: A**
**Explanation:** Phép mã hóa trong RSA là tính m^e mod n. Nếu e nhỏ, hoặc có dạng nhị phân ít bit 1 (như 65537 = 10000000000000001_2), thì việc tính lũy thừa module sẽ nhanh hơn đáng kể so với việc chọn e lớn và ngẫu nhiên. Việc này quan trọng vì mã hóa/kiểm tra chữ ký thường được thực hiện thường xuyên hơn giải mã/ký.

Q99. SET (Secure Electronic Transaction) sử dụng kỹ thuật gì để đảm bảo người bán không thấy được thông tin thẻ của khách hàng, và cổng thanh toán không thấy được chi tiết đơn hàng?
A. Sử dụng kỹ thuật "Phong bì số kép" (Dual Signature), kết hợp chữ ký số và mã hóa để liên kết thông tin đơn hàng và thông tin thanh toán mà không tiết lộ chéo chúng.
B. Mã hóa toàn bộ thông tin bằng khóa công khai của ngân hàng.
C. Chia thông tin thành hai phần và gửi qua hai kênh riêng biệt.
D. Yêu cầu khách hàng nhập mã OTP cho mỗi giao dịch.
**Correct answer: A**
**Explanation:** SET sử dụng một cơ chế đặc biệt gọi là Dual Signature. Khách hàng tạo hash cho thông tin đơn hàng (OI) và thông tin thanh toán (PI), nối hai hash lại, tạo hash của chuỗi nối đó, rồi ký lên hash cuối cùng bằng khóa riêng. Sau đó mã hóa OI bằng khóa công khai người bán, mã hóa PI bằng khóa công khai cổng thanh toán. Người bán chỉ giải mã được OI, cổng thanh toán chỉ giải mã được PI, nhưng cả hai có thể xác minh chữ ký kép để đảm bảo mối liên kết giữa OI và PI mà không thấy được phần còn lại.

Q100. Phân tích sự khác biệt cơ bản giữa mô hình tin cậy dựa trên CA (Hierarchical/Trust Anchor) trong PKI và mô hình Mạng lưới tin cậy (Web of Trust) trong PGP.
A. PKI/CA: Tin cậy tập trung vào một hoặc một số CA gốc, có cấu trúc phân cấp rõ ràng. PGP/WoT: Tin cậy phi tập trung, dựa trên việc người dùng ký và xác nhận lẫn nhau khóa của người khác, tạo thành mạng lưới tin cậy ngang hàng.
B. PKI an toàn hơn PGP/WoT.
C. PGP/WoT dễ quản lý hơn PKI.
D. PKI dùng cho email, PGP/WoT dùng cho website.
**Correct answer: A**
**Explanation:** PKI truyền thống (X.509) dựa trên mô hình phân cấp với các CA gốc (Root CA) là neo tin cậy. Mọi chứng chỉ phải được truy vết về một CA gốc được tin tưởng. PGP thì khác, nó cho phép người dùng tự quyết định mức độ tin cậy vào khóa của người khác dựa trên chữ ký của những người mà họ đã tin tưởng (có thể là trực tiếp hoặc gián tiếp qua nhiều bậc), tạo ra một mô hình phi tập trung hơn.
